<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Templates Manager</title>
  <style>
    body { font-family: system-ui, sans-serif; background: #1e1e1e; color: #ddd; margin: 0; }
    header { padding: 12px 16px; background: #2b2b2b; border-bottom: 1px solid #3a3a3a; display:flex; gap:16px; align-items:center; }
    main { display: grid; grid-template-columns: 320px 1fr; gap: 16px; padding: 16px; }
    .panel { background: #252525; border: 1px solid #3a3a3a; border-radius: 6px; padding: 12px; }
    label { display: block; margin-bottom: 8px; }
    input[type=text], select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #555; background: #1f1f1f; color: #ddd; }
    button { padding: 8px 12px; border-radius: 4px; border: 1px solid #555; background: #333; color: #eee; cursor: pointer; }
    button:hover { background: #3d3d3d; }
    .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; flex-wrap: wrap; }
    .row label { display: inline-flex; align-items: center; gap: 6px; margin-right: 8px; }
    .row label select, .row label input { width: auto; }
    small { color: #999; }
    nav a { color: #9bd; text-decoration: none; }
    nav a:hover { text-decoration: underline; }
    #preview { width: 100%; max-height: 70vh; object-fit: contain; background: #111; border: 1px solid #3a3a3a; border-radius: 6px; }
  </style>
</head>
<body>
  <header>
    <div><strong>Templates Manager</strong></div>
    <nav style="display:flex; gap:12px">
      <a href="/">Dashboard</a>
      <a href="/static/sequences.html">Sequences</a>
      <a href="/static/groups.html">Groups</a>
      <a href="/static/control.html">Controls</a>
      <a href="/static/schedules.html">Schedules</a>
      <a href="/static/templates.html">Templates</a>
      <a href="/static/failsafe.html">Failsafe</a>
      <a href="/static/debug.html">Debug</a>
    </nav>
    <div style="margin-left:auto; display:flex; align-items:center; gap:8px">
      <label style="display:flex; align-items:center; gap:6px"><input type="checkbox" id="rememberToken" /> Remember token</label>
      <input type="text" id="token" placeholder="Access Token" style="width:260px" />
      <span id="globalLiveDot" title="Server live status" style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#555"></span>
      <small id="globalLiveText">Live: disconnected</small>
    </div>
  </header>
  <main>
    <div class="panel">
      <label>
        Templates
        <select id="tplList" size="14"></select>
      </label>
      <div class="row">
        <input type="text" id="newTplName" placeholder="New template name" />
        <input type="text" id="newTplPath" placeholder="Relative path (e.g., images/RuneOre.png)" />
        <button id="btnAdd">Add</button>
      </div>
      <div class="row">
        <input type="text" id="uploadName" placeholder="Upload name (maps to template)" />
        <input type="file" id="uploadFile" accept="image/png, image/jpeg" />
        <button id="btnUpload">Upload</button>
      </div>
      <div class="row">
        <button id="btnDelete">Delete Selected</button>
      </div>
      <div style="margin-top:8px"><small id="statusA">Status: idle</small></div>
      <div style="margin-top:4px"><small id="statusU">Upload: idle</small></div>
    </div>
    <div class="panel">
      <div class="row">
        <label style="flex:1">Name
          <input type="text" id="tplName" disabled />
        </label>
      </div>
      <div class="row">
        <label style="flex:1">Path
          <input type="text" id="tplPath" />
        </label>
        <button id="btnSave">Save Path</button>
      </div>
      <img id="preview" alt="Preview" />
      <div style="margin-top:8px"><small id="statusB">Status: idle</small></div>
    </div>
    <div class="panel">
      <h4>Live Preview</h4>
      <div id="tplPreviewWrap" style="width:100%">
        <div class="row" style="margin-bottom:8px">
          <label>Monitor
            <select id="tplMonitor"></select>
          </label>
          <label style="margin-left:16px">Size
            <select id="tplPreviewSize"><option>640</option><option>800</option><option selected>1024</option><option>1280</option></select>
          </label>
          <label style="margin-left:16px; display:inline-flex; align-items:center; gap:6px"><input type="checkbox" id="tplPhoneToggle" /> Using Phone</label>
          <label style="margin-left:16px; display:inline-flex; align-items:center; gap:6px"><input type="checkbox" id="tplJpegToggle" /> JPEG</label>
          <label style="display:inline-flex; align-items:center; gap:6px">Quality <input type="number" id="tplJpegQuality" min="1" max="95" value="75" style="width:70px" /></label>
          <label style="display:inline-flex; align-items:center; gap:6px">Scale <input type="number" id="tplJpegScale" min="0.25" max="1" step="0.05" value="1" style="width:70px" /></label>
          <span id="tplFpsText" style="margin-left:16px"><small>FPS: --</small></span>
        </div>
        <div id="tplImagePane" style="position:relative; width:100%">
          <img id="tplPreview" alt="Preview" draggable="false" class="no-drag" style="width:100%; max-height:60vh; object-fit:contain; background:#111; border:1px solid #3a3a3a; border-radius:6px" />
          <div id="tplSel" style="display:none; position:absolute; border:2px dashed #9bd; background:rgba(155, 221, 255, 0.15); pointer-events:none"></div>
        </div>
        <div class="row" style="margin-top:8px">
          <input type="text" id="tplSelName" placeholder="Template name (e.g., RuneOre)" style="flex:1" />
          <button id="btnCaptureTpl">Save Selection as Template</button>
        </div>
        <div style="margin-top:8px"><small id="statusC">Status: idle</small></div>
      </div>
      <small>Live preview shows your screen via MJPEG; use Monitor to switch.</small>
    </div>
  </main>

  <script>
    const apiBase = '';
    const tokenEl = document.getElementById('token');
    const rememberEl = document.getElementById('rememberToken');
    const tplListEl = document.getElementById('tplList');
    const previewEl = document.getElementById('preview');
    const statusA = document.getElementById('statusA');
    const statusB = document.getElementById('statusB');
    const tplPhoneToggle = document.getElementById('tplPhoneToggle');
    const globalLiveDot = document.getElementById('globalLiveDot');
    const globalLiveText = document.getElementById('globalLiveText');
    let sseGlobal = null; let sseGlobalRetryMs = 1000;
    // Live preview elements
    const tplPreview = document.getElementById('tplPreview');
    const tplImagePane = document.getElementById('tplImagePane');
    let tplMonitors = [];
    let tplSelectedMonitor = 0;

    function authHeaders() {
      const tok = tokenEl.value.trim();
      return tok ? { 'Authorization': `Bearer ${tok}` } : {};
    }

    // Token persistence across pages
    try {
      const remembered = (localStorage.getItem('rememberToken') === 'true');
      rememberEl.checked = remembered;
      const savedTok = localStorage.getItem('apiToken') || '';
      if (remembered && savedTok && !tokenEl.value) tokenEl.value = savedTok;
    } catch (e) {}
    tokenEl.addEventListener('change', () => {
      try { if (rememberEl.checked) localStorage.setItem('apiToken', tokenEl.value.trim()); } catch (e) {}
      fetchTemplates(); startGlobalStatusStream();
    });
    rememberEl.addEventListener('change', () => {
      try {
        localStorage.setItem('rememberToken', rememberEl.checked ? 'true' : 'false');
        if (rememberEl.checked) localStorage.setItem('apiToken', tokenEl.value.trim());
      } catch (e) {}
    });

    // Live preview helpers
    tplPreview.addEventListener('dragstart', (e) => e.preventDefault());
    function setTplPreviewSize(){
      const val = parseInt(document.getElementById('tplPreviewSize').value||'1024',10);
      if (!isNaN(val) && val>0) { tplPreview.style.width = `${val}px`; }
      // Reproject existing selection overlay to new preview size
      try { tplRenderRegionOverlay(); } catch (e) {}
    }
    document.getElementById('tplPreviewSize').addEventListener('change', setTplPreviewSize);
    // Load persisted preview settings
    (function loadTplPreviewPrefs(){
      try {
        const fmt = localStorage.getItem('preview.format');
        const qual = localStorage.getItem('preview.quality');
        const scale = localStorage.getItem('preview.scale');
        const mon = localStorage.getItem('preview.monitor');
        const tgl = document.getElementById('tplJpegToggle');
        const ql = document.getElementById('tplJpegQuality');
        const sc = document.getElementById('tplJpegScale');
        if (fmt && tgl) tgl.checked = (fmt === 'jpeg');
        if (qual && ql) { const v = parseInt(qual,10); if(!isNaN(v)) ql.value = String(v); }
        if (scale && sc) { let v = parseFloat(scale); if(!isNaN(v)) { v = Math.max(0.25, Math.min(1.0, v)); sc.value = String(v); } }
        if (mon) { const mv = parseInt(mon,10); if(!isNaN(mv)) tplSelectedMonitor = mv; }
      } catch (e) {}
    })();
    function updateTplPreviewSrc(){
      const tok = tokenEl.value.trim();
      const useJpeg = !!(document.getElementById('tplJpegToggle')?.checked);
      const fmt = useJpeg ? 'jpeg' : 'png';
      const scaleEl = document.getElementById('tplJpegScale');
      const qualEl = document.getElementById('tplJpegQuality');
      const q = [
        `monitor=${encodeURIComponent(tplSelectedMonitor)}`,
        `format=${fmt}`
      ];
      let scaleVal = parseFloat(scaleEl?.value||'1');
      if (!isNaN(scaleVal)) { scaleVal = Math.max(0.25, Math.min(1.0, scaleVal)); q.push(`scale=${scaleVal.toFixed(2)}`); }
      if (useJpeg) {
        const qualVal = parseInt(qualEl?.value||'75', 10);
        if (!isNaN(qualVal)) q.push(`quality=${Math.max(1, Math.min(95, qualVal))}`);
      }
      if (tok) q.push(`token=${encodeURIComponent(tok)}`);
      tplPreview.src = `${apiBase}/stream.mjpeg?${q.join('&')}`;
    }
    document.getElementById('tplJpegToggle').addEventListener('change', ()=>{ const useJpeg = !!document.getElementById('tplJpegToggle').checked; localStorage.setItem('preview.format', useJpeg ? 'jpeg' : 'png'); updateTplPreviewSrc(); });
    document.getElementById('tplJpegQuality').addEventListener('change', ()=>{ const v = parseInt(document.getElementById('tplJpegQuality').value||'75',10); if(!isNaN(v)) localStorage.setItem('preview.quality', String(v)); updateTplPreviewSrc(); });
    document.getElementById('tplJpegScale').addEventListener('change', ()=>{ let v = parseFloat(document.getElementById('tplJpegScale').value||'1'); if(!isNaN(v)) { v = Math.max(0.25, Math.min(1.0, v)); localStorage.setItem('preview.scale', String(v)); } updateTplPreviewSrc(); });
    async function fetchTplMonitors(){
      try {
        const res = await fetch(`${apiBase}/api/monitors`, { headers: authHeaders() });
        const data = await res.json();
        tplMonitors = data.monitors || [];
        const sel = document.getElementById('tplMonitor');
        sel.innerHTML = '';
        for (const m of tplMonitors) {
          const opt = document.createElement('option');
          opt.value = String(m.index);
          opt.textContent = (m.index === 0) ? `All (${m.width}x${m.height})` : `Monitor ${m.index} (${m.width}x${m.height})`;
          sel.appendChild(opt);
        }
        sel.value = String(tplSelectedMonitor);
        sel.addEventListener('change', (e)=>{ tplSelectedMonitor = parseInt(e.target.value||'0',10)||0; localStorage.setItem('preview.monitor', String(tplSelectedMonitor)); updateTplPreviewSrc(); });
      } catch (e) { /* ignore */ }
    }

    async function fetchTemplates() {
      try {
        const res = await fetch(`${apiBase}/api/templates`, { headers: authHeaders() });
        const data = await res.json();
        tplListEl.innerHTML = '';
        for (const t of (data.templates || [])) {
          const opt = document.createElement('option');
          opt.value = t.name; opt.textContent = `${t.name}${t.exists ? '' : ' (missing)'}`;
          tplListEl.appendChild(opt);
        }
        statusA.textContent = `Status: loaded ${tplListEl.options.length} template(s)`;
      } catch (e) { statusA.textContent = `Status: failed (${e.message})`; }
    }

    async function loadTemplate(name) {
      if (!name) { document.getElementById('tplName').value = ''; document.getElementById('tplPath').value = ''; previewEl.src = ''; return; }
      try {
        const res = await fetch(`${apiBase}/api/templates/${encodeURIComponent(name)}`, { headers: authHeaders() });
        const t = await res.json();
        if (res.ok) {
          document.getElementById('tplName').value = t.name;
          document.getElementById('tplPath').value = t.path || '';
          const tok = tokenEl.value.trim();
          previewEl.src = `${apiBase}/api/template-image?name=${encodeURIComponent(name)}${tok ? `&token=${encodeURIComponent(tok)}` : ''}`;
          statusB.textContent = `Status: ${t.exists ? 'preview loaded' : 'file missing'}`;
        } else {
          statusB.textContent = `Status: failed to load (${t.error})`;
          previewEl.src = '';
        }
      } catch (e) { statusB.textContent = `Status: error (${e.message})`; }
    }

    async function savePath() {
      const name = document.getElementById('tplName').value;
      const path = document.getElementById('tplPath').value.trim();
      if (!name) { statusB.textContent = 'Status: select template'; return; }
      if (!path) { statusB.textContent = 'Status: enter path'; return; }
      try {
        const res = await fetch(`${apiBase}/api/templates/${encodeURIComponent(name)}`, {
          method: 'PUT', headers: { ...authHeaders(), 'Content-Type': 'application/json' }, body: JSON.stringify({ path })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
        statusB.textContent = 'Status: path saved';
        await fetchTemplates();
        await loadTemplate(name);
      } catch (e) { statusB.textContent = `Status: save failed (${e.message})`; }
    }

    async function addTemplate() {
      const name = document.getElementById('newTplName').value.trim();
      const path = document.getElementById('newTplPath').value.trim();
      if (!name || !path) { statusA.textContent = 'Status: enter name and path'; return; }
      try {
        const res = await fetch(`${apiBase}/api/templates`, {
          method: 'POST', headers: { ...authHeaders(), 'Content-Type': 'application/json' }, body: JSON.stringify({ name, path })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
        statusA.textContent = 'Status: template added';
        document.getElementById('newTplName').value = '';
        document.getElementById('newTplPath').value = '';
        await fetchTemplates();
      } catch (e) { statusA.textContent = `Status: add failed (${e.message})`; }
    }

    async function deleteTemplate() {
      const name = tplListEl.value;
      if (!name) { statusA.textContent = 'Status: select template'; return; }
      try {
        const res = await fetch(`${apiBase}/api/templates/${encodeURIComponent(name)}`, {
          method: 'DELETE', headers: authHeaders()
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
        statusA.textContent = 'Status: template deleted';
        document.getElementById('tplName').value = '';
        document.getElementById('tplPath').value = '';
        previewEl.src = '';
        await fetchTemplates();
      } catch (e) { statusA.textContent = `Status: delete failed (${e.message})`; }
    }

    async function uploadTemplate() {
      const name = document.getElementById('uploadName').value.trim();
      const fileEl = document.getElementById('uploadFile');
      const statusU = document.getElementById('statusU');
      if (!name) { statusU.textContent = 'Upload: enter name'; return; }
      if (!fileEl.files || fileEl.files.length === 0) { statusU.textContent = 'Upload: choose file'; return; }
      const file = fileEl.files[0];
      const mime = (file.type || '').toLowerCase();
      let ext = 'png';
      if (mime.includes('jpeg')) ext = 'jpg';
      else if (mime.includes('png')) ext = 'png';
      statusU.textContent = 'Upload: reading file...';
      try {
        const dataUrl = await new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onerror = () => reject(new Error('file read error'));
          reader.onload = () => resolve(reader.result);
          reader.readAsDataURL(file);
        });
        statusU.textContent = 'Upload: sending...';
        const res = await fetch(`${apiBase}/api/templates/upload`, {
          method: 'POST',
          headers: { ...authHeaders(), 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, image_base64: String(dataUrl), ext })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
        statusU.textContent = `Upload: ok (${data.path || 'saved'})`;
        // Reset inputs and refresh list
        document.getElementById('uploadName').value = '';
        document.getElementById('uploadFile').value = '';
        await fetchTemplates();
        // Select and load the uploaded template
        tplListEl.value = name;
        await loadTemplate(name);
      } catch (e) {
        statusU.textContent = `Upload: failed (${e.message})`;
      }
    }

    tplListEl.addEventListener('change', () => loadTemplate(tplListEl.value));
    document.getElementById('btnSave').addEventListener('click', savePath);
    document.getElementById('btnAdd').addEventListener('click', addTemplate);
    document.getElementById('btnDelete').addEventListener('click', deleteTemplate);
    document.getElementById('btnUpload').addEventListener('click', uploadTemplate);
    tokenEl.addEventListener('change', () => { fetchTemplates(); fetchTplMonitors().then(()=>{ updateTplPreviewSrc(); setTplPreviewSize(); }); });
    // Capability gating: enable JPEG controls only if supported
    async function fetchMetrics(){
      try {
        const res = await fetch(`${apiBase}/api/metrics`, { headers: authHeaders() });
        const data = await res.json();
        const caps = (data && data.capabilities) ? data.capabilities : {};
        const jpegOk = !!(caps.pillow_available && caps.jpeg_supported);
        const tgl = document.getElementById('tplJpegToggle');
        const ql = document.getElementById('tplJpegQuality');
        const sc = document.getElementById('tplJpegScale');
        if (tgl && ql && sc) {
          tgl.disabled = !jpegOk;
          ql.disabled = !jpegOk;
          sc.disabled = false; // scale works for both
        }
        if (!jpegOk && tgl) { tgl.checked = false; updateTplPreviewSrc(); }
      } catch (e) { /* ignore */ }
    }
    fetchMetrics();

    // Prevent default image drag which interferes on touch devices
    previewEl.addEventListener('dragstart', (e) => e.preventDefault());
    // Toggle touch-action to disable scrolling during interactions (for future selection tools)
    function updateTplTouchAction(){ tplImagePane.style.touchAction = tplPhoneToggle.checked ? 'none' : 'auto'; }
    tplPhoneToggle.addEventListener('change', updateTplTouchAction);
    updateTplTouchAction();

    // Region selection overlay logic (mouse + touch)
    const tplSelBox = document.getElementById('tplSel');
    let tplDragStart = null;
    let tplLastDragPos = null;
    let tplLastRegion = null; // [x,y,w,h] in natural image pixels

    // Compute actual drawn content rect inside the <img> (object-fit: contain)
    function getTplImageContentInfo(img){
      const rect = img.getBoundingClientRect();
      const nw = img.naturalWidth || rect.width;
      const nh = img.naturalHeight || rect.height;
      const elemW = rect.width, elemH = rect.height;
      let contentW = elemW;
      let contentH = contentW * (nh / nw);
      if (contentH > elemH){
        contentH = elemH;
        contentW = contentH * (nw / nh);
      }
      const offsetX = (elemW - contentW) / 2;
      const offsetY = (elemH - contentH) / 2;
      return { rect, nw, nh, contentW, contentH, offsetX, offsetY };
    }

    function tplStartDrag(clientX, clientY){
      const paneRect = tplImagePane.getBoundingClientRect();
      const info = getTplImageContentInfo(tplPreview);
      const ix = clientX - info.rect.left - info.offsetX;
      const iy = clientY - info.rect.top - info.offsetY;
      if (ix < 0 || iy < 0 || ix > info.contentW || iy > info.contentH) return;
      const offX = (info.rect.left - paneRect.left) + info.offsetX;
      const offY = (info.rect.top - paneRect.top) + info.offsetY;
      tplDragStart = { x: ix, y: iy, offX, offY };
      tplSelBox.style.display = 'block';
      tplSelBox.style.left = `${offX + ix}px`;
      tplSelBox.style.top = `${offY + iy}px`;
      tplSelBox.style.width = '0px';
      tplSelBox.style.height = '0px';
    }
    function tplMoveDrag(clientX, clientY){
      if (!tplDragStart) return;
      const info = getTplImageContentInfo(tplPreview);
      let ix = clientX - info.rect.left - info.offsetX; let iy = clientY - info.rect.top - info.offsetY;
      ix = Math.max(0, Math.min(info.contentW, ix));
      iy = Math.max(0, Math.min(info.contentH, iy));
      tplLastDragPos = { x: ix, y: iy };
      const left = Math.min(tplDragStart.x, ix) + tplDragStart.offX;
      const top = Math.min(tplDragStart.y, iy) + tplDragStart.offY;
      const w = Math.abs(ix - tplDragStart.x);
      const h = Math.abs(iy - tplDragStart.y);
      tplSelBox.style.left = `${left}px`;
      tplSelBox.style.top = `${top}px`;
      tplSelBox.style.width = `${w}px`;
      tplSelBox.style.height = `${h}px`;
    }
    function tplEndDrag(){
      if (!tplDragStart) return;
      const info = getTplImageContentInfo(tplPreview);
      const ix0 = Math.min(tplDragStart.x, (tplLastDragPos ? tplLastDragPos.x : tplDragStart.x));
      const iy0 = Math.min(tplDragStart.y, (tplLastDragPos ? tplLastDragPos.y : tplDragStart.y));
      const iw = Math.abs(((tplLastDragPos ? tplLastDragPos.x : tplDragStart.x)) - tplDragStart.x);
      const ih = Math.abs(((tplLastDragPos ? tplLastDragPos.y : tplDragStart.y)) - tplDragStart.y);
      const scaleX = info.nw / info.contentW;
      const scaleY = info.nh / info.contentH;
      // Compensate for server-side image scale so region is in monitor coordinates
      let serverScale = parseFloat((document.getElementById('tplJpegScale').value||'1'));
      if (isNaN(serverScale) || serverScale <= 0) serverScale = 1;
      const x0 = Math.round((ix0 * scaleX) / serverScale);
      const y0 = Math.round((iy0 * scaleY) / serverScale);
      const rw = Math.round((iw * scaleX) / serverScale);
      const rh = Math.round((ih * scaleY) / serverScale);
      tplLastRegion = [x0, y0, rw, rh];
      statusC.textContent = `Status: selected region ${x0},${y0},${rw},${rh}`;
      tplDragStart = null;
      tplLastDragPos = null;
    }
    // Re-render selection overlay from saved monitor-space region after preview reload/scale change
    function tplRenderRegionOverlay(){
      if (!tplLastRegion) return;
      const info = getTplImageContentInfo(tplPreview);
      const paneRect = tplImagePane.getBoundingClientRect();
      const scaleX = info.nw / info.contentW;
      const scaleY = info.nh / info.contentH;
      let serverScale = parseFloat((document.getElementById('tplJpegScale').value||'1'));
      if (isNaN(serverScale) || serverScale <= 0) serverScale = 1;
      const [mx, my, mw, mh] = tplLastRegion;
      const ix0 = (mx * serverScale) / scaleX;
      const iy0 = (my * serverScale) / scaleY;
      const iw = (mw * serverScale) / scaleX;
      const ih = (mh * serverScale) / scaleY;
      const offX = (info.rect.left - paneRect.left) + info.offsetX;
      const offY = (info.rect.top - paneRect.top) + info.offsetY;
      tplSelBox.style.display = 'block';
      tplSelBox.style.left = `${offX + ix0}px`;
      tplSelBox.style.top = `${offY + iy0}px`;
      tplSelBox.style.width = `${iw}px`;
      tplSelBox.style.height = `${ih}px`;
    }
    // Mouse events
    tplPreview.addEventListener('mousedown', (e) => { tplStartDrag(e.clientX, e.clientY); });
    tplPreview.addEventListener('mousemove', (e) => { tplMoveDrag(e.clientX, e.clientY); });
    tplPreview.addEventListener('load', () => { tplRenderRegionOverlay(); });
    window.addEventListener('mouseup', () => { tplEndDrag(); });
    // Touch events gated by Using Phone
    tplPreview.addEventListener('touchstart', (e) => { if (!tplPhoneToggle.checked) return; e.preventDefault(); const t=e.touches[0]; if (t) tplStartDrag(t.clientX, t.clientY); }, { passive: false });
    tplPreview.addEventListener('touchmove', (e) => { if (!tplPhoneToggle.checked || !tplDragStart) return; e.preventDefault(); const t=e.touches[0]; if (t) tplMoveDrag(t.clientX, t.clientY); }, { passive: false });
    window.addEventListener('touchend', () => { if (!tplPhoneToggle.checked) return; tplEndDrag(); });

    // Save selection as template
    async function captureTemplateFromSelection(){
      try {
        const nameRaw = (document.getElementById('tplSelName').value || '').trim();
        let name = nameRaw;
        if (!name) {
          const dt = new Date();
          const pad = (n)=>String(n).padStart(2,'0');
          name = `tpl_${dt.getFullYear()}${pad(dt.getMonth()+1)}${pad(dt.getDate())}_${pad(dt.getHours())}${pad(dt.getMinutes())}${pad(dt.getSeconds())}`;
        }
        if (!tplLastRegion || tplLastRegion[2] <= 0 || tplLastRegion[3] <= 0){
          statusC.textContent = 'Status: select a region first';
          return;
        }
        const [x, y, width, height] = tplLastRegion;
        const res = await fetch(`${apiBase}/api/templates/capture`, {
          method: 'POST', headers: { ...authHeaders(), 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, monitor: tplSelectedMonitor, x, y, width, height })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
        statusC.textContent = `Status: saved '${name}' to ${data.path}`;
        document.getElementById('tplSelName').value = '';
        // Refresh lists and show preview
        await fetchTemplates();
        tplListEl.value = name;
        await loadTemplate(name);
      } catch (e) {
        statusC.textContent = `Status: save failed (${e.message})`;
      }
    }
    document.getElementById('btnCaptureTpl').addEventListener('click', captureTemplateFromSelection);

    const urlTok = new URLSearchParams(location.search).get('token');
    if (urlTok) { tokenEl.value = urlTok; }
    fetchTemplates();
    fetchTplMonitors().then(()=>{ updateTplPreviewSrc(); setTplPreviewSize(); });
    // Live FPS meter via /api/metrics
    (function attachTplFps(){
      const out = document.getElementById('tplFpsText');
      let lastFrames = null; let lastTime = null;
      async function poll(){
        try {
          const res = await fetch(`${apiBase}/api/metrics`, { headers: authHeaders() });
          const data = await res.json();
          const frames = (data && data.totals && typeof data.totals.preview_mjpeg_frames === 'number') ? data.totals.preview_mjpeg_frames : 0;
          const now = Date.now();
          if (lastFrames !== null && lastTime !== null) {
            const df = frames - lastFrames; const dt = (now - lastTime) / 1000;
            if (dt > 0) { const fps = Math.max(0, df / dt); if (out) out.textContent = `FPS: ${fps.toFixed(1)}`; }
          }
          lastFrames = frames; lastTime = now;
        } catch (e) { /* ignore */ }
      }
      setInterval(poll, 1000); poll();
    })();
    startGlobalStatusStream();

    function startGlobalStatusStream(){
      const tok = (tokenEl.value || localStorage.getItem('apiToken') || '').trim();
      if (!tok) { globalLiveText.textContent = 'Live: enter token'; globalLiveDot.style.background = '#555'; return; }
      try { if (sseGlobal) { sseGlobal.close(); sseGlobal = null; } } catch {}
      const url = `${apiBase}/api/status/stream?interval_ms=1000&token=${encodeURIComponent(tok)}`;
      globalLiveText.textContent = 'Live: connecting...';
      globalLiveDot.style.background = '#caa';
      try {
        sseGlobal = new EventSource(url);
        sseGlobal.onopen = () => { globalLiveText.textContent = 'Live: connected'; globalLiveDot.style.background = '#3fb950'; sseGlobalRetryMs = 1000; };
        sseGlobal.onmessage = (evt) => {
          try {
            const msg = JSON.parse(evt.data);
            const ts = Number(msg.heartbeat || Date.now());
            globalLiveText.textContent = `Live: heartbeat ${ts}`;
            globalLiveDot.style.background = '#3fb950';
          } catch (e) {
            globalLiveText.textContent = 'Live: bad data'; globalLiveDot.style.background = '#f59e0b';
          }
        };
        sseGlobal.onerror = () => {
          globalLiveText.textContent = 'Live: disconnected, retrying...'; globalLiveDot.style.background = '#555';
          try { sseGlobal.close(); } catch {}
          sseGlobal = null;
          const delay = Math.min(sseGlobalRetryMs, 10000);
          setTimeout(startGlobalStatusStream, delay);
          sseGlobalRetryMs = Math.min(sseGlobalRetryMs * 2, 10000);
        };
      } catch (e) {
        globalLiveText.textContent = `Live: error (${e.message})`;
        globalLiveDot.style.background = '#ef4444';
      }
    }
  </script>
</body>
</html>